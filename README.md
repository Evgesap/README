# Тестовая работа в GitHub.

----


В этом небольшом экскурсе я расскажу Вам зачем я это все пишу.
Так вот, дорогой читатель, все это написано для того, чтобы выполнить тестовую работу для *Яндекс Практикума*, а именно для курса GitHub для начинаюших. Ну вобщем Вы поняли ? - Да?  - Поняли же?


Вобщем поехали!


Это первое что я должен сделать! - А именно сделать обучающий гайд для человека который хочет овладеть навыком работы с _GitHub_, так что придется постараться!


Первое чему придется научится, это работа с навигацией в git:  


1. cd /C/../ - Перемешение по директориям (путь от папки до папки).  
2. cd .. - Выход из директории (выход из папки).  
3. pwd - Вывод пути в директории (Выводит путь от папки до папки).  
4. ls - Отображает файлы находяшиеся в директории.  
5. ls -a -Отображает скрытые файлы в директории.  
6. mkdir (название папки) - создает новую директорию (каталог).  
7. touch (название файла) - сщдает новый файл.  
8. cat (файли) - Отображает файл (только текстовые файлы).  
9. rm (название файла) - Удаление файла.  
10. rmdir (назвавние файла) - Удаляет папку из текушей директории.  
11. rm -r (название файла) - удаляет файлы находящиеся в папке а затем и папку.  
12. cp (название файла) (директория копирования файла) - Копирование файла.  
13. mv (название файла) (директория перемешения файла) - перемешения файла.  
14. mkdir web-project && cd web-project && touch index.html style.css - Пример того как можно обьединять команды.  


И так с чего начинается работа в git:


1. Создаем папку с проектом и открываем GIT Bash в этой папке.    
2. git init - инициализация папки git.  
3. git add --all - подготовка файлов к сохранению.  
4. git status - Проверка готовности файлов к комиту.  
5. git commit -m "комментарий" -сохраняем файлы.     
6. git log - История коммитов.  
7. Создаем удаленный репозиторий в GitHub.  
8. cd ~ - Перейти в домашнюю директорию.  
9. ls -la .ssh - Проверка наличия ключей ssh.  
10. ssh-keygen -t ed25519 -C ""электронная почта, к которой привязан ваш аккаунт на GitHub" - Генерация ключей ssh.  
11. ls -a ~/.ssh - Проверка установки ключей ssh.  
12. clip < ~/.ssh/id_ed25519.pub - Вывододим содерживое папки ssh и копируем содержимое.  
_Если clip не сработает, выведите содержимое файла с помощью cat ~/.ssh/id_rsa.pub или cat ~/.ssh/id_ed25519.pub и скопируйте вывод в буфер обмена из консоли._  
13. Перейдите на GitHub и выберите пункт Settings (англ. «настройки») в меню аккаунта.  
14. В меню слева нажмите на пункт SSH and GPG keys.   
15. В открывшейся вкладке выберите New SSH key (англ. «новый SSH-ключ»).  
16. В поле Title (англ. «заголовок») напишите название ключа. Например, Personal key (англ. «личный ключ»).  
18. В поле Key type (англ. «тип ключа») должно быть Authentication Key (англ. «ключ аутентификации»).  
19. В поле Key скопируйте ваш ключ из буфера обмена.  
20. Нажмите на кнопку Add SSH key (англ. «добавить SSH-ключ»).  
21. ssh -T git@github.com - Проверка правильность ключа с помощью следующей команды.  
_Если это первый раз, когда вы используете Git, чтобы поделиться проектом на GitHub, появится похожее предупреждение. - The authenticity of host 'github.com (140.82.121.4)' can't be established. ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU. This key is not known by any other names. Are you sure you want to continue connecting (yes/no/[fingerprint])?_  
22. cd ~/dev/first-project - перейдите в каталог локального репозитория.   
23. git remote add origin git@github.com:%ИМЯ_АККАУНТА%/first-project.git - Команде необходимо передать два параметра: имя удалённого репозитория и его URL. В качестве имени используйте слово origin. А URL вы скопировали со страницы удалённого репозитория.  
24. git remote -v - Убедиться, что репозитории связаны.  
25. git push origin main - Отправляешь фаил на удаенный репозиторий.  


## Что такое хеш. Хеширование коммитов.


Git хранит таблицу соответствий хеш ? информация о коммите. Если вы знаете хеш, вы можете узнать всё остальное: автора и дату коммита и содержимое закоммиченных файлов. Можно сказать, что хеш — основной идентификатор коммита.
При работе с Git хеши будут встречаться вам регулярно. Их можно будет передавать в качестве параметра разным Git-командам, чтобы указать, с каким коммитом нужно произвести то или иное действие.
Все хеши и таблицу хеш ? информация о коммите Git сохраняет в служебные файлы. Они находятся в скрытой папке .git в репозитории проекта.


Информация о коммите — это набор данных: когда был сделан коммит, содержимое файлов в репозитории на момент коммита и ссылка на предыдущий, или родительский (англ. parent), коммит.
Git хеширует (преобразует) информацию о коммите с помощью алгоритма SHA-1 (от англ. Secure Hash Algorithm — «безопасный алгоритм хеширования») и получает для каждого коммита свой уникальный хеш — результат хеширования.
Обычно хеш — это короткая(40 символов в случае SHA-1) строка, которая состоит из цифр 0—9и латинских букв ??—??(неважно, заглавных или строчных). Она обладает следующими важными свойствами:  


* если хеш получить дважды для одного и того же набора входных данных, то результат будет гарантированно одинаковый;  
*  если хоть что-то в исходных данных поменяется (хотя бы один символ), то хеш тоже изменится (причём сильно).  


Чтобы убедиться в этом, можно поэкспериментировать с SHA-1 на этом сайте — попробуйте ввести в поле input (англ. «ввод») разные символы, слова или предложения и понаблюдайте, как меняется хеш в поле output (англ. «вывод»).


## Лог в GIT.


После вызова git log появляется список коммитов.

Разберём элементы, из которых состоит описание:  
* строка из цифр и латинских букв после слова commit — это хеш коммита;
* Author — имя автора и его электронная почта;
* Date — дата и время создания коммита;
*в конце находится сообщение коммита.


### Получить сокращённый лог.


1. git log --oneline - Получить сокращённый лог можно с помощью команды git log с флагом --oneline (англ. «одной строкой»). В терминале появятся только первые несколько символов хеша каждого коммита и их комментарии.  


Сокращённый лог полезен, если в репозитории уже много коммитов — например, сотни или тысячи. В этом случае можно быстро найти нужный по описанию.
Сокращённый хеш (то есть первые несколько символов полного) можно использовать точно так же, как и полный. Для этого команда git log --oneline автоматически подбирает такую длину сокращённых хешей, чтобы они были уникальными в пределах репозитория и Git всегда мог понять, о каком коммите идёт речь.  


_Обратите внимание: если выход из просмотра логов не произошёл автоматически, нажмите клавишу Q (от англ. Quit — «выйти») в английской раскладке клавиатуры._  


## HEAD. 


При вызове команды git log вы также могли заметить надпись (HEAD -> master) после хеша одного из коммитов. В этом уроке расскажем, что она означает.  


Файл HEAD (англ. «голова», «головной») — один из служебных файлов папки .git. Он указывает на коммит, который сделан последним (то есть на самый новый).  


В этом можно убедиться с помощью терминала. Перейдите в папку .git командой cd. Посмотрите содержимое файла HEAD командой cat.

```
$ pwd # посмотрели, где мы
/Users/user/dev/first-project
```
```
$ cd .git/
$ ls # посмотрели, какие есть файлы
COMMIT_EDITMSG  ORIG_HEAD  description  index  logs/     refs/
HEAD            config     hooks/       info/  objects/
```
```
$ cat HEAD # команда cat показывает содержимое файла
ref: refs/heads/master # в файле вот такая ссылка
```


Внутри HEAD — ссылка на служебный файл: refs/heads/master (или refs/heads/main в зависимости от названия ветки). Если заглянуть в этот файл, можно увидеть хеш последнего коммита. 

```
$ cat refs/heads/master # взяли ссылку из файла HEAD
# внутри хеш
e007f5035f113f9abca78fe2149c593959da5eb7
```
```
$ git log 
# сверяем с хешем последнего коммита
commit e007f5035f113f9abca78fe2149c593959da5eb7
Author: John Doe <johndoe@example.com>
Date:   Tue Mar 28 00:26:53 2023 +0300
    
    Добавить амбиций в список дел
   
... # другие коммиты  
```


Когда вы делаете коммит, Git обновляет refs/heads/master — записывает в него хеш последнего коммита. Получается, что HEAD тоже обновляется, так как ссылается на refs/heads/master.
При работе с Git указатель HEAD используется довольно часто. Мы уже упоминали, что многие команды Git принимают в качестве параметра хеш коммита. Если нужно передать последний коммит, то вместо его хеша можно просто написать слово HEAD — Git поймёт, что вы имели в виду последний коммит.  


## Статусы файлов в Git.


До появления Git системы контроля версий выделяли только два статуса у файлов: «уже закоммичен» и «ещё не закоммичен». Например, в Subversion (самой популярной VCS до эпохи Git) не нужно было выполнять команду — аналог git add, а можно было просто сделать коммит (svn commit). Эта команда по умолчанию добавляла в коммит все новые и изменённые файлы.
Такое поведение интуитивно более понятно. Зато Git даёт больше контроля за состоянием файлов. Хотя сначала это может показаться сложным, со временем вы оцените удобство более явного подхода.
В этом уроке разберём подробнее, в каких состояниях (или статусах) могут находиться файлы в репозитории. А ещё проследим типичный жизненный цикл файла в Git.  


### Статусы untracked/tracked, staged и modified.


Одна из ключевых задач Git — отслеживать изменения файлов в репозитории. Для этого каждый файл помечается каким-либо статусом. Рассмотрим основные.  

* untracked (англ. «неотслеживаемый»)

Мы говорили, что новые файлы в Git-репозитории помечаются как untracked, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У untracked-файла нет предыдущих версий, зафиксированных в коммитах или через команду git add.  


* staged (англ. «подготовленный»)  

  После выполнения команды git add файл попадает в staging area (от англ. stage — «сцена», «этап [процесса]» и area — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии staged.
  В одном из предыдущих уроков мы сравнили коммит с фотографией. Можно развить эту аналогию и сказать, что команда git add добавляет персонажей (текущее содержимое файла или нескольких файлов) на сцену (англ. stage) для общей фотографии, а git commit делает снимок всей сцены целиком. 


**Staging area, index и cache**
_Staging area также называют index (англ. «каталог») или cache (англ. «кеш»), а состояние файла staged иногда называют indexed или cached.
Все три варианта могут встречаться в документации и в качестве флагов команд Git. А также в интернете — например, в вопросах и ответах на сайте Stack Overflow._  

* tracked (англ. «отслеживаемый»)  

Состояние tracked — это противоположность untracked. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью git commit, а также файлы, которые были добавлены в staging area командой git add. То есть все файлы, в которых Git так или иначе отслеживает изменения.  

* modified (англ. «изменённый»)  

Состояние modified означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.  


 _Для файлов в состояниях staged и modified обычно не указывают, что они также tracked, потому что это состояние подразумевается._  


### Про staged и modified.


Команда git add добавляет в staging area только текущее содержимое файла. Если вы, например, сделаете git add file.txt, а затем измените file.txt, то новое содержимое файла не будет находиться в staging.
Git сообщит об этом с помощью статуса modified: файл изменён относительно той версии, которая уже в staging. Чтобы добавить в staging последнюю версию, нужно выполнить git add file.txt ещё раз.  


### Типичный жизненный цикл файла в Git.


Может показаться, что файлы в репозитории попадают в разные состояния хаотично. На практике это не так, и у большинства файлов вполне предсказуемый путь.  


```mermaid
flowchart TD;
  A[untracked (отслеживаемый)] --> B[git add];
  B[git add] --> C[stated (в списке на коммит) + tracked];
  C[stated (в списке на коммит) + tracked] --> D[git commit];
  D[git commit] --> E[tracked (отслеживаемый)];
  E[tracked (отслеживаемый)] --> F[изменения];
  F[изменения] --> G[modified (изменённый)];
  G[modified (изменённый)] --> H[git add];
  H[git add] --> C[stated (в списке на коммит) + tracked];
```


1. Файл только что создали. Git ещё не отслеживает содержимое этого файла. Состояние: untracked.  
2. Файл добавили в staging area с помощью git add. Состояние: staged (+ tracked).  
* Возможно, изменили файл ещё раз. Состояния: staged, modified (+ tracked).  
Обратите внимание: staged и modified у одного файла, но у разных его версий.  
* Ещё раз выполнили git add. Состояние: staged (+ tracked).  
3. Сделали коммит с помощью git commit. Состояние: tracked.
4. Изменили файл. Состояние: modified (+ tracked).  
5. Снова добавили в staging area с помощью git add. Состояния: staged (+ tracked).  
6. Сделали коммит. Состояния: tracked.  
7. Повторили пункты 4?7 много-много раз.  


Выглядит довольно запутанно! Но на практике разобраться с этим будет проще, чем кажется.


## Как читать git status.  


### Какие состояния показывает git status.


Большинство файлов в типичном проекте будут находиться в состоянии tracked (то есть закоммичены и не изменены после коммита). Вы не увидите это состояние в выводе команды git status — иначе она бы каждый раз выводила список вообще всех файлов проекта.
В итоге git status показывает только следующие состояния файлов:
* staged (Changes to be committed в выводе git status);
* modified (Changes not staged for commit);
* untracked (Untracked files).


Команда git status всегда подскажет, что происходит с файлом: например, он добавлен в список «на коммит» или ещё вообще не отслеживается, или изменён.
* git status показывает явно следующие состояния файлов: untracked, staged и modified.
* git status подсказывает, какие команды можно выполнить, чтобы поменять состояние файла.


Надеюсь эта небольшая инструкция поможет Вам и как и мне работать с GIT и в будушем, Вы и я овладеете навыком работы  в _системе контроля версии_ (GIT) и передадите навык следующим кто захочет научится этому.

